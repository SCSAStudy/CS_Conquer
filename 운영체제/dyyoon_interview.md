## [유진]
- windows와 linux의 차이점**
  - UI
    - 윈도우는 GUI기반의 운영체제이고, 리눅스는 CLI기반의 운영체제이다. 
  - 비용
    - 윈도우는 마이크로소프트 사에서 개발한 상용 소프트웨어로 유로로 판매되고 있으며,
      리눅스는 오픈 소스로 누구나 사용이 가능해 무료로 다운로드 받을 수 있다.
  - 보안성    
    - 리눅스는 다중 사용자 체제이므로 관리자 권한(root)으로 로그인 하지 않으면 모든 사용자는 보호 모드에서 작동하므로 윈도우에 비해 바이러스가 매우 적고 보안성이 높은 편이다.
리눅스의 모든 소스는 인터넷상에 공개되어 있기 때문에 보안이슈 발생 시 발빠른 대처가 가능하다. (오픈소스이기 때문에)
반면, 윈도우는 리눅스에 비해 시스템 버그나 보안 취약점 발견 시 패치가 나오는데 상당한 시일이 걸린다.
  - [참고링크](https://spidyweb.tistory.com/69)

- **유닉스와 리눅스의 차이점**
  - [참고링크](https://btcd.tistory.com/360)
- **리눅스 배포판으로 많은 것이 있잖아요? 실제로 어떤걸 사용했는지, 그리고 그걸 왜 사용했는지?**
  - 경험 질문
- **프로세스에 대해서 설명해주세요.**
  - 메모리에 적재되어 실행되고 있는 프로그램
- **리눅스 서버가 갑자기 느려졌을 때, 어떻게 대응할 것인지**
  - 원인 점검, 로그 확인, 프로세스 확인, 메모리 확인, 네트워크 확인, 디스크 확인
  - 확인 후 해결 방안을 찾아서 적용

## [요셉]
- **스레드가 어떤 것인가요? 그리고 실제 프로젝트에서 스레드를 사용해본 적이 있나요?**
  - 프로세스(process) 내에서 실제로 작업을 수행하는 주체를 의미합니다.
- **임계영역 동기화 기법으로 무엇이 있나요?**
    - 뮤텍스, 세마포어, 모니터
    - 뮤텍스(Mutex):
      - 목적: 상호 배제를 위한 동기화 기법입니다. 하나의 스레드나 프로세스가 임계 영역(Critical Section)에 진입하면 다른 스레드나 프로세스는 해당 영역에 들어갈 수 없습니다.
      - 동작: 뮤텍스는 이진 상태(0 또는 1)를 가지며, 임계 영역에 들어가기 전에 뮤텍스를 획득하고, 사용이 끝난 후에는 반드시 뮤텍스를 해제해야 합니다.
    - 세마포어(Semaphore):
      - 목적: 리소스에 대한 접근을 여러 프로세스 또는 스레드가 동시에 제어하고자 할 때 사용됩니다.
      - 동작: 정수 변수로, P(V)와 V(S) 두 개의 연산으로 제어됩니다. P 연산은 세마포어 값을 감소시키고, 값이 0보다 작으면 대기하도록 합니다. V 연산은 세마포어 값을 증가시키고, 대기 중인 프로세스나 스레드를 깨웁니다. 
    - 모니터(Monitor):
      - 목적: 공유 데이터에 대한 접근을 동기화하기 위한 추상화된 데이터 구조입니다. 모니터 안에서 선언된 프로시저나 메소드는 동시에 하나의 스레드만 실행될 수 있습니다.
      - 동작: 모니터는 내부에 잠금(lock)을 가지고 있어서 한 번에 하나의 스레드만 모니터 내의 코드를 실행할 수 있습니다. 다른 스레드가 접근하려면 대기해야 합니다. 모니터를 통해 동기화를 간편하게 구현할 수 있으며, 대부분의 고수준 프로그래밍 언어에서 제공됩니다.
- **페이지 교체 알고리즘에 대해서 설명해주세요.**
  - **FIFO(first in first out)**
    - 가장 간단한 알고리즘으로, 메모리에 올라온 지 가장 오래된 페이지를 교체합니다. 간단하고, 초기화 코드에 대해 적절한 방법이며, 페이지가 올라온 순서를 큐에 저장합니다.
  - **최적(Optimal) 페이지 교체**
      - 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체하는 알고리즘입니다. 최적 페이지 교체는 선행 조건이 있는데, 프로세스가 앞으로 사용할 페이지를 미리 알아야 한다는 것입니다. 이 조건은 실제 활용에선 알 방법이 없기 때문에 최적 알고리즘은 구현이 불가능한 알고리즘입니다. 때문에 연구를 목적으로 주로 사용됩니다.
  - **LRU(least-recently-used)**
      - 가장 오래 사용되지 않은 페이지를 교체하는 알고리즘입니다. OPT 알고리즘의 방식과 비슷한 효과를 낼 수 있는 방법이며, OPT 알고리즘보다 페이지 교체 횟수가 높지만 FIFO 알고리즘 보다 효율적입니다.
  - **LFU(least-frequently-used)**
      - 참조 횟수가 가장 작은 페이지를 교체하는 알고리즘입니다. 만약 대상인 페이지가 여러 개 일 경우, LRU 알고리즘을 따라 가장 오래 사용되지 않은 페이지로 교체합니다.
  - **MFU(most-frequently-used)**
      - LFU 알고리즘과 반대로, 참조 횟수가 가장 많은 페이지를 교체하는 알고리즘입니다.
- **CPU 스케줄링에 대해서 설명해주세요.**
  - 선점, 비선점으로 나뉜다. 선점은 프로세스가 CPU를 할당받아 실행 중에도 다른 프로세스가 CPU를 강제로 빼앗을 수 있고, 비선점은 프로세스가 CPU를 할당받으면 CPU를 반환할 때까지 실행한다.
  - 비선점은 한 프로세스가 한 번 CPU를 점유했다면 프로세스가 종료될 때까지 다른 프로세스가 CPU를 점유하지 못하는 것이다.
  - FCFS
    - 먼저 온 프로세스를 먼저 처리하는 방식이다. 비선점형 스케줄링이다.
  - SJF
    - 가장 짧은 CPU 시간을 가진 프로세스를 먼저 처리하는 방식이다. 비선점형 스케줄링이다.
  - 우선순위
    - 우선순위가 높은 프로세스를 먼저 처리하는 방식이다. 비선점형 스케줄링이다.
  - RR
    - Round Robin의 약자로, 시분할 시스템을 위해 설계된 선점형 스케줄링이다. 각 프로세스는 동일한 크기의 할당 시간을 갖게 된다.
  - 다단계 큐
    - 프로세스를 여러 개의 그룹으로 나누고, 각 그룹마다 큐를 만들어 관리하는 방식이다. 각 큐는 자신의 스케줄링 알고리즘을 가지고 있다.
  - 다단계 피드백 큐
    - 다단계 큐에서 프로세스가 큐를 이동할 수 있도록 한 것이다. 프로세스가 CPU를 할당받아 실행되는 동안에는 우선순위가 높은 큐에서 실행되고, 할당 시간이 만료되면 우선순위가 낮은 큐로 이동한다. 이때, 우선순위가 낮은 큐에 프로세스가 대기 중이면 CPU를 선점한다.
- **멀티 스레드 프로그래밍을 하는 이유가 뭘까요? 데드락이 발생해서 임계영역을 설정해야 한다면 단순히 싱글 스레드를 사용하면 되지 않을까요?**
  - 성능 향상:
    - 멀티 스레드를 사용하면 여러 작업을 동시에 수행할 수 있어, 시스템의 전반적인 성능을 향상시킬 수 있습니다. 특히, CPU 바운드 작업에서는 멀티 코어를 활용하여 병렬 처리를 통해 성능 향상을 기대할 수 있습니다.
  - 응답성 향상:
    - 멀티 스레드를 사용하면 한 스레드에서 작업을 수행하는 동안 다른 스레드가 대기하지 않고 동작할 수 있습니다. 이로 인해 시스템이 더 빠르게 응답하고, 사용자 경험이 향상될 수 있습니다.
  - 작업 분리 및 모듈화:
    - 멀티 스레드를 사용하면 프로그램을 여러 스레드로 나누어 작업을 분리하고 모듈화할 수 있습니다. 이는 코드의 가독성과 유지 보수성을 향상시키며, 복잡한 작업을 더 쉽게 다룰 수 있도록 합니다.
  - 자원 공유:
    - 멀티 스레드를 사용하면 프로세스 간의 통신과 비교하여 스레드 간의 통신이 간단하고 효율적입니다. 공유 메모리를 통한 데이터 공유가 용이하며, 이로써 여러 스레드가 동시에 작업을 수행할 수 있습니다.
  - 멀티코어 프로세서 활용:
    - 현대의 대부분의 시스템은 멀티코어 프로세서를 사용하고 있습니다. 멀티 스레드를 사용하면 이러한 멀티코어 환경에서 더 효과적으로 자원을 활용할 수 있습니다.


## [록형]
- **멀티 스레드와 멀티 프로세싱의 차이점**
- **멀티 스레드 프로그래밍을 하는 이유가 뭘까요? 데드락이 발생해서 임계영역을 설정해야 한다면 단순히 싱글 스레드를 사용하면 되지 않을까요?**
- **프로세스와 스레드의 차이점**
- **실제 프로젝트에서 비동기 프로그래밍을 해본 적이 있나요?**
- **Spirng은 싱글 스레드 모델인가요? 멀티 스레드 모델인가요?**