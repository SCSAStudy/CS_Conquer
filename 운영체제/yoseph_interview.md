## [유진]

1. 프로세스 생명주기에 대해 설명해주세요.
   - 생성 : 프로세스가 생성되면 PCB가 함께 생성됩니다.
   - 생성 -> 준비(admitted) : 프로세스가 초기화와 같은 작업을 하고 실행할 준비를 합니다.
   - 준비 -> 실행(dispatch) : CPU를 점유하며 프로세스가 실행됩니다.
   - 실행 -> 대기(IO or event wait) : 입출력이나 이벤트를 기다리며 대기상태로 전환합니다.
   - 대기 -> 준비(IO or event completion) : 입출력이나 이벤트에 의해 준비상태로 전환됩니다.
   - 종료 : 완전히 프로세스가 종료됩니다.
2. BSD 라이선스에 대해 설명해주세요.
   - BSD 계열 소프트웨어에 적용되는 오픈소스 라이선스
   - 소스코드 공개의 의무가 없습니다. BSD 라이선스의 소프트웨어를 이용하는 경우, 해당 저작권자의 이름과 BSD 라이선스의 내용을 같이 배포해야 한다.
3. 리눅스가 왜 다른 OS에 비해 이식성과 확장성이 뛰어난가요?
   - 거의 C언어와 어셈블리어로 작성되어 있습니다.
   - C언어 자체가 기계에 비의존적이기 때문에 프로그램을 다른 기계의 시스템으로 포팅하는 것이 쉽습니다.
   - OS 자체도 하드웨어에 적합하게 변형이 가능하며 x86용으로 개발된 리눅스가 SPARC이나 맥의 Power PC, Alpha에 모두 적용될 수 있습니다.
4. RAID 분류에 대해서 설명해주세요.
   - RAID 0 : 스트라이핑 기능(분배 기록) 사용. 빠른 I/O 성능, 고장 대비 능력 X
   - RAID 1 : 두 개 이상의 디스크를 미러링을 통해 하나의 디스크처럼 사용.
   - RAID 2 : ECC(에러 검출 기능) 탑재
   - RAID 3 : 하나의 디스크를 에러검출을 위한 패리티 정보 저장용으로 사용하고 나머지 디스크에 데이터를 균등하게 분산 저장
   - RAID 4 : RAID 3 방식과 같지만 블록 단위로 분산 저장
   - RAID 5 : 하나의 디스크에 패리티 정보를 저장하지 않고 분산 저장 (회전식 패리티 어레이)
   - RAID 6 : 하나의 패리티 정보를 두개의 디스크에 분산 저장. 쓰기 능력은 저하될 수 있지만 고장 대비 능력이 매
     우 높음. 두 개의 오류까지 검출 가능.
   - RAID 7 : 실시간 운영체계를 사용
   - RAID 0+1 : 최소 4개 이상의 디스크를 2개씩 스트라이핑으로 묶고(RAID 0) 미러링으로 결합(RAID 1)한 방식
   - RAID 10 : 두 개의 디스크를 미러링으로 묶고(RAID 1) 스트라이핑(RAID 0)으로 결합한 방식
5. 저널링 기술에 대해서 설명해주세요.
   - 데이터를 디스크에 쓰기 전에 로그에 데이터를 남겨 fsck보다 빠르고 안정적인 복구 기능을 제공하는 기술
6. 데비안과 슬랙웨어에 대해 설명해주세요.
   - 데비안 : GNU의 후원을 받는 리눅스 배포판, 패키지 설치 및 업그레이드가 단순하다. (패키지 관리 - dpkg, apt)
   - 슬랙웨어 : 초창기에 나온 배포판으로 현재까지 살아있는 가장 오래된 배포판. 구조가 간결하나 설치과정이 어렵고 패키지 관리가 어려워 많이 사용되지는 않는다.
7. 페이지 교체 알고리즘 중 현대 운영체제에서 많이 사용하는 알고리즘과 그 알고리즘의 작동 방식에 대해 설명해주세요.
   - 현대 운영체제에서는 LRU를 많이 사용하며 LRU는 사용한지 가장 오래된 페이지를 교체하는 방식으로 작동합니다.



## [다영]

1. 이중 모드 환경에서 유저 프로세스가 운영체제 기능을 어떻게 사용하는지 설명해주세요.
   - 커널은 유저 프로세스가 운영체제 기능을 사용할 수 있도록 시스템 콜에 고유번호를 부여하고 이것을 바탕으로 추상적인 인터페이스를 제공합니다. 유저 프로세스는 이 시스템콜 인터페이스를 통해 운영체제 기능을 사용할 수 있습니다.
   
2. 동시성과 병렬성에 대해 설명해주세요.
   - 동시성 : Context Switching에 의해 매우 빠르게 프로세스(or 스레드)를 실행시켜 동시에 실행되는 것처럼 보이는 특징. 소프트웨어 측면 성능 향상과 관련있다.
   - 병렬성 : 여러 프로세스나 코어를 사용하여 실제로 동시에 여러 작업을 처리하는 것으로 성능을 향상시키기 위함을 말한다. 하드웨어 측면 성능 향상과 관련있다.
   
3. 페이지 교체 알고리즘 중 현대 운영체제에서 많이 사용하는 알고리즘과 그 알고리즘의 작동 방식에 대해 설명해주세요.
   - 현대 운영체제에서는 LRU를 많이 사용하며 LRU는 사용한지 가장 오래된 페이지를 교체하는 방식으로 작동합니다.
   
4. 교착상태 회피 기법에 대해 설명해주세요.
   - 교착상태 회피 기법에는 **프로세스 시작중지**, **자원할당거부**가 있습니다. **프로세스 시작중지**는 프로세스가 요청과 해제때마다 자원의 순서를 파악하여 요청에 따른 프로세스 대기 여부를 결정하는 것이고, **자원할당거부**는 은행원 알고리즘(Banker's Algorithm)을 사용하여 자원 할당 허용 여부를 결정하기 전에 총 가능 할당량을 파악하여 안전여부를 검사하여 불안전한 상황인 경우 자원할당을 거부하는 방법을 말합니다.
   
5. 페이징 기법과 세그멘테이션의 기법의 각각 쓰임새에 대해서 설명해주세요.
   - 페이징 기법은 외부단편화를 해결하기 위해, 세그멘테이션 기법은 내부 단편화를 해결하기 위해 사용합니다. 여기서 세그멘테이션이 프로세스를 논리적 내용을 기반으로 나눈다는 특징을 활용한 단편화 해결 이외의 용도가 존재하는데, 바로 보호와 공유에 장점이 있다는 것입니다. 논리적 내용을 기반으로 프로세스를 나누었기 때문에 영역별로 구별지을 수가 있어 보호와 공유에 용이합니다.
   
6. SJF 스케줄링을 선점방식으로 실행한다면 어떤 과정으로 실행되는지 설명해주세요.
   - 만약 현재 A 프로세스가 수행중인데 B 프로세스가 요청되었다고 가정해보겠습니다. A 프로세스는 실행 시간이 4초, B 프로세스는 실행시간이 3초입니다. 그렇다면 B 프로세스가 CPU를 선점하게 됩니다. 즉, 다른 프로세스가 요청되는 시점에 남아있는 프로세스들 중에 실행 시간이 가장 짧은 프로세스가 CPU를 점유하는 방식으로 실행됩니다. 남아있는 프로세스들의 시간을 비교하여 선점한다고 해서 **Shortest Remaining Time First**라고도 부릅니다.
   
7. 주소 바인딩에 대해 설명해주세요.
   1. 컴파일 타임 바인딩(Compile-Time Binding):
      - 프로그램이 컴파일될 때 논리적 주소가 물리적 주소로 변환되어 메모리에 할당된다. 이 방식은 실행 중에 주소의 변화가 없으며, 실행 파일이 메모리에 로드될 때 이미 주소가 고정되어 있다.
      
   2. 로드 타임 바인딩(Load-Time Binding):
      - 프로그램이 로드될 때 논리적 주소가 물리적 주소로 변환되어 메모리에 할당된다. 실행 파일이 메모리에 로드되는 동안 주소를 결정하며, 주소가 고정된다.
      
   3. 실행 타임 바인딩(Runtime Binding):
      - 프로그램이 실행 중일 때 논리적 주소가 물리적 주소로 동적으로 변환된다. 이 방식은 가상 메모리와 관련이 있으며, 프로세스 실행 도중 메모리의 어느 위치에 어떤 데이터가 위치하는지가 결정된다.
      
        

