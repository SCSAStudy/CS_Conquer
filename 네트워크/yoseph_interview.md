## 다영

**네트워크**

1. 웹 소켓과 소켓 통신의 차이에 대해 설명해주세요.
   - 웹 소켓과 소켓 통신의 차이는 데이터 형식과 계층 위치입니다. 웹 소켓은 HTTP 프로토콜이 존재하는 응용계층, 소켓은 TCP/UDP 프로토콜이 존재하는 전송 계층에 위치합니다. 소켓은 바이트 스트림을 통한 바이트 데이터가 전송되고 웹 소켓은 메시지 형식의 데이터를 전송합니다.
   - 웹 소켓과 소켓은 상반된 개념이 아니므로 완전히 차이점을 말할 수는 없습니다. 웹에서도 TCP 프로토콜을 통해 소켓 통신을 할 수 있지만 바이트 형식의 데이터보다는 메시지 형식의 데이터를 기반으로 통신하는 것이 개발에 있어서 더 용이하기 때문에 TCP 소켓 통신을 기반으로 웹 애플리케이션에 맞춰 발전된 것이 웹 소켓입니다.
  
2. 쿠키와 세션의 작동방식에 대해 설명해주세요.
   - 쿠키의 작동 방식은 클라이언트가 서버에 페이지를 요청하면 서버에서 쿠키를 생성하여 http 헤더에 쿠키를 포함시켜 응답합니다. 
   - 사용자 정보를 자체에 담아 클라이언트에 보관하고 요청시에 HTTP 헤더에 쿠키를 포함시켜 보냅니다.
   - 서버에서 쿠키를 읽어 이전 상태 정보에 변경이 필요할 경우 업데이트 하여 헤더에 담아 응답합니다.
   - 세션의 작동 방식은 클라이언트가 서버에 접근하면 세션 ID를 발급받습니다.
   - 클라이언트는 세션 ID 정보를 쿠키에 저장하여 갖고 있습니다.
   - 클라이언트는 서버에 요청시 세션 ID가 담긴 쿠키를 같이 전달합니다.
   - 서버는 세션 ID를 전달받아 해당 세션에 있는 클라이언트 정보를 가져와 사용합니다.
   - 클라이언트 정보를 갖고 요청을 처리하여 응답합니다.
  
3. TCP keep alive 와 HTTP keep alive의 차이점에 대해 설명해주세요.
   - 둘 다 영속성 커넥션을 보장하는 방법이지만 TCP keep alive는 유령 세션 제거에 더 목적을 두고 있습니다.

4. L4, L7 로드밸런서를 각각 설명해주세요.
   - L4 로드 밸런서는 전송 계층에서 작동하며 TCP, UDP 프로토콜을 기반으로 클라이언트와 서버의 부하를 분산시킵니다. 클라이언트와 서버의 IP, 포트를 기반으로 로드밸런싱을 수행합니다. 패킷의 헤더 정보만을 사용하므로 속도가 빠르지만 다양한 기능 과 유연성에서는 제한됩니다.
   - L7 로드 밸런서는 응용 계층에서 작동하며 HTTP 프로토콜을 기반으로 부하를 분산시킵니다. 요청 내용, 즉 URL, 헤더, 쿠키를 기반으로 로드밸런싱을 수행합니다. 다양한 기능과 유연성이 보장되지만 그로 인해 처리해야할 것들이 많아 상대적으로 속도는 느립니다.
5. 4-way-handshake 과정 중 서버가 FIN 패킷을 보내기 전에 전송한 패킷들이 라우팅 지연이나 패킷 유실로 인한 재전송등으로 FIN 패킷보다 늦게 도착하면 어떻게 되는지?
   - 클라이언트에서 세션을 종료시킨 이후 도착한 패킷들은 드랍되고 데이터는 유실됩니다.
6. 위 문제를 방지하기 위해 클라이언트는 어떤 방식으로 작동하는지?
   - FIN을 수신하더라도 일정 시간 세션을 유지시켜 잉여 패킷을 기다리게 되는데 이를 TIME_WAIT이라고 합니다. 일정시간이 지나면 세션을 만료하고 연결을 종료합니다.
7. TLS Handshake 과정에 대해 설명해주세요.
   - 최초 서버에 요청을 보내면 서버가 클라이언트에 공개키(인증서)를 보냅니다
   - 클라이언트는 해당 인증서의 유효성 검사를 마친후 세션키를 발급합니다.
   - 다시 이 세션키를 서버에게서 받은 공개키로 암호화하여 서버로 보냅니다.
   - 서버는 자신의 개인키를 사용해 세션키를 복호화하여 얻습니다.
   - 이 세션키를 대칭키로 사용하여 클라이언트 서버간 데이터 전달시에 사용하여 빠른 데이터 전달을 가능하게 합니다.
8. HTTP는 왜 Stateless 구조를 채택하고 있을까요?
   - 서버는 클라이언트의 정보를 저장하지 않고 이는 상호간 결합도가 낮다는 것을 의미합니다. 따라서, 서버의 수평적 확장 즉, 스케일 아웃에 용이하기 때문에 이를 채택하였습니다.
9.  라우터 내의 포워딩 과정을 설명해주세요.
    - 링크상태 알고리즘, 거리벡터 알고리즘과 같은 라우팅 알고리즘을 통해 패킷이 목적지로 가기위한 정보들을 포워딩 테이블을 구성하여 저장합니다. 포워딩 테이블에는 목적지 IP 주소, 출력 포트, 넥스트홉, 인터페이스와 같은 정보들이 구성됩니다. 이를 참조하여 적절한 포트를 통해 패킷을 목적지로 보내게 됩니다.
10. HTTP/1.1 과 HTTP/2의 차이점은 무엇인가요?
    - HTTP/1.1에서는 단순 텍스트 기반 메시지형식으로 응답 요청을 보내던 것을 HTTP/2.0 에서는 이진 포맷을 사용한 경량화를 한 스트림을 통해 응답 요청을 처리합니다. HTTP/2.0에서는 응답 요청쌍을 길이가 정이된 한개의 프레임 안에 담겨져 스트림을 통해 보내집니다. 한 개의 스트림 쌍이 요청 응답 쌍을 처리할 수 있고 이 스트림은 한 개의 커넥션 안에 여러개가 만들어질 수 있어 여러개의 응답 요청을 처리할 수 있습니다. 이 스트림을 통해 HTTP/1.1의 응답 지연과 영속적 커넥션에서 발생할 수 있는 문제점을 개선하였습니다.


<br/>

### 록형

**운영체제**

1. 이중 모드 환경에서 유저 프로세스가 운영체제 기능을 어떻게 사용하는지 설명해주세요.
   - 커널은 유저 프로세스가 운영체제 기능을 사용할 수 있도록 시스템 콜에 고유번호를 부여하고 이것을 바탕으로 추상적인 인터페이스를 제공합니다. 유저 프로세스는 이 시스템콜 인터페이스를 통해 운영체제 기능을 사용할 수 있습니다.
   
2. 동시성과 병렬성에 대해 설명해주세요.
   - 동시성 : Context Switching에 의해 매우 빠르게 프로세스(or 스레드)를 실행시켜 동시에 실행되는 것처럼 보이는 특징. 소프트웨어 측면 성능 향상과 관련있다.
   - 병렬성 : 여러 프로세스나 코어를 사용하여 실제로 동시에 여러 작업을 처리하는 것으로 성능을 향상시키기 위함을 말한다. 하드웨어 측면 성능 향상과 관련있다.
   
3. 페이지 교체 알고리즘 중 현대 운영체제에서 많이 사용하는 알고리즘과 그 알고리즘의 작동 방식에 대해 설명해주세요.
   - 현대 운영체제에서는 LRU를 많이 사용하며 LRU는 사용한지 가장 오래된 페이지를 교체하는 방식으로 작동합니다.
   
4. 교착상태 회피 기법에 대해 설명해주세요.
   - 교착상태 회피 기법에는 **프로세스 시작중지**, **자원할당거부**가 있습니다. **프로세스 시작중지**는 프로세스가 요청과 해제때마다 자원의 순서를 파악하여 요청에 따른 프로세스 대기 여부를 결정하는 것이고, **자원할당거부**는 은행원 알고리즘(Banker's Algorithm)을 사용하여 자원 할당 허용 여부를 결정하기 전에 총 가능 할당량을 파악하여 안전여부를 검사하여 불안전한 상황인 경우 자원할당을 거부하는 방법을 말합니다.
   
5. 페이징 기법과 세그멘테이션의 기법의 각각 쓰임새에 대해서 설명해주세요.
   - 페이징 기법은 외부단편화를 해결하기 위해, 세그멘테이션 기법은 내부 단편화를 해결하기 위해 사용합니다. 여기서 세그멘테이션이 프로세스를 논리적 내용을 기반으로 나눈다는 특징을 활용한 단편화 해결 이외의 용도가 존재하는데, 바로 보호와 공유에 장점이 있다는 것입니다. 논리적 내용을 기반으로 프로세스를 나누었기 때문에 영역별로 구별지을 수가 있어 보호와 공유에 용이합니다.
   
6. SJF 스케줄링을 선점방식으로 실행한다면 어떤 과정으로 실행되는지 설명해주세요.
   - 만약 현재 A 프로세스가 수행중인데 B 프로세스가 요청되었다고 가정해보겠습니다. A 프로세스는 실행 시간이 4초, B 프로세스는 실행시간이 3초입니다. 그렇다면 B 프로세스가 CPU를 선점하게 됩니다. 즉, 다른 프로세스가 요청되는 시점에 남아있는 프로세스들 중에 실행 시간이 가장 짧은 프로세스가 CPU를 점유하는 방식으로 실행됩니다. 남아있는 프로세스들의 시간을 비교하여 선점한다고 해서 **Shortest Remaining Time First**라고도 부릅니다.
   
7. 주소 바인딩에 대해 설명해주세요.
   1. 컴파일 타임 바인딩(Compile-Time Binding):
      - 프로그램이 컴파일될 때 논리적 주소가 물리적 주소로 변환되어 메모리에 할당된다. 이 방식은 실행 중에 주소의 변화가 없으며, 실행 파일이 메모리에 로드될 때 이미 주소가 고정되어 있다.
      
   2. 로드 타임 바인딩(Load-Time Binding):
      - 프로그램이 로드될 때 논리적 주소가 물리적 주소로 변환되어 메모리에 할당된다. 실행 파일이 메모리에 로드되는 동안 주소를 결정하며, 주소가 고정된다.
      
   3. 실행 타임 바인딩(Runtime Binding):
      - 프로그램이 실행 중일 때 논리적 주소가 물리적 주소로 동적으로 변환된다. 이 방식은 가상 메모리와 관련이 있으며, 프로세스 실행 도중 메모리의 어느 위치에 어떤 데이터가 위치하는지가 결정된다.
      
        



**네트워크**

1. SOP 정책에 대해 설명해주세요.
   - 동일 출처 정책으로 동일한 출처에 대한 리소스와만 상호작용을 허용하겠다는 정책입니다.
2. Cors 정책에 대해 설명해주시고 동작 과정에 대해 설명해주세요.
   - 개발 편의상 SOP 정책에 위배되어야 하는 예외적 상황을 위해 등장한 정책입니다. 다른 출처의 리소스도 상호작용을 허용하도록 하는 정책입니다. 클라이언트는 HTTP 패킷에 자신의 프로토콜, 호스트, 포트 정보를 Origin 헤더에 담아 서버로 전송합니다. 서버는 이 Origin 헤더를 확인하여 어느 사이트인지 확인할 수 있습니다. 서버는 다른 출처와의 상호작용을 Access-Control-Allow-Origin 헤더를 통해 이를 설정합니다. 이 헤더에 상호작용을 허용하고자 하는 도메인을 명시하면 됩니다.
3. Stateless 와 Connectionless 에 대해 설명해주세요.
   - Stateless : 무상태성이라는 뜻으로 서버가 클라이언트의 정보를 저장하지 않는 특징입니다.
   - Connectionless : 클라이언트가 요청하는 것 이외에는 연결하고 있지 않는 특징입니다.
4. HTTP는 왜 Stateless 구조를 채택하고 있을까요?
   - 서버는 클라이언트의 정보를 저장하지 않고 이는 상호간 결합도가 낮다는 것을 의미합니다. 따라서, 서버의 수평적 확장 즉, 스케일 아웃에 용이하기 때문에 이를 채택하였습니다.
5. 라우터 내의 포워딩 과정을 설명해주세요.
   - 링크상태 알고리즘, 거리벡터 알고리즘과 같은 라우팅 알고리즘을 통해 패킷이 목적지로 가기위한 정보들을 포워딩 테이블을 구성하여 저장합니다. 포워딩 테이블에는 목적지 IP 주소, 출력 포트, 넥스트홉, 인터페이스와 같은 정보들이 구성됩니다. 이를 참조하여 적절한 포트를 통해 패킷을 목적지로 보내게 됩니다.
6. HTTP/1.1 과 HTTP/2의 차이점은 무엇인가요?
   - HTTP/1.1에서는 단순 텍스트 기반 메시지형식으로 응답 요청을 보내던 것을 HTTP/2.0 에서는 이진 포맷을 사용한 경량화를 한 스트림을 통해 응답 요청을 처리합니다. HTTP/2.0에서는 응답 요청쌍을 길이가 정이된 한개의 프레임 안에 담겨져 스트림을 통해 보내집니다. 한 개의 스트림 쌍이 요청 응답 쌍을 처리할 수 있고 이 스트림은 한 개의 커넥션 안에 여러개가 만들어질 수 있어 여러개의 응답 요청을 처리할 수 있습니다. 이 스트림을 통해 HTTP/1.1의 응답 지연과 영속적 커넥션에서 발생할 수 있는 문제점을 개선하였습니다.
7. IP 주소는 무엇이며 어떤 기능을 하나요?
   - 인터넷 네트워크 상에서 상호간 통신하는 기기들을 식별하는 고유 번호입니다. 네트워크 내에서 특정기기를 찾아 데이터를 전송할 수 있게 해줍니다.